<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>十大经典排序算法</title>
    <url>/2020/11/23/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>参考了博客<a href="https://www.cnblogs.com/onepixel/articles/7674659.html">十大经典排序算法(动图演示)</a>，该博客上还有排序的相关图解和JS代码实现，非常清晰</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li>
</ul>
<a id="more"></a>

<p>​        下面代码通用的排序工具类，用于提供打印数组的方法和测试数据，并且下面排序算法都是按从小到大排序(从大到小反推即可)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:array)</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span>+i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] array1=&#123;<span class="number">100</span>,<span class="number">889</span>,<span class="number">4678</span>,<span class="number">1354</span>,<span class="number">20</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">225</span>,<span class="number">502</span>,<span class="number">765</span>,<span class="number">12</span>,<span class="number">10058</span>,<span class="number">52</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] array2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">77</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">80</span>,<span class="number">464</span>,<span class="number">124</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] array3=&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">38</span>,<span class="number">156</span>,<span class="number">1</span>,<span class="number">564</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">65</span>,<span class="number">51</span>,<span class="number">321</span>,<span class="number">3</span>,<span class="number">54</span>,<span class="number">31</span>,<span class="number">23</span>,<span class="number">150</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>冒泡排序的特点就是在交换相邻数组元素时，元素会一步一步地向末尾端移动，像冒泡一样</p>
<p>时间复杂度(平均)：O(n^2)</p>
<p>时间复杂度(最好)：O(n)</p>
<p>时间复杂度(最差)：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array=SortUtil.array1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里设置j的上限为array.length-1可以减少无效循环语句的执行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;array.length-<span class="number">1</span>-i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                	<span class="comment">//冒泡的核心部分在于相邻元素的交换</span></span><br><span class="line">                    <span class="keyword">int</span> temp=array[j];</span><br><span class="line">                    array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SortUtil.printArray(array);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h2><p>选择排序的特点在于把数组分为有序和无序的，初始数组全为无序部分，然后从中选择最小(大)值放到有序部分(有序部分从数组的0下标开始)，依次执行直到无序部分遍历结束</p>
<p>时间复杂度(平均)：O(n^2)</p>
<p>时间复杂度(最好)：O(n^2)</p>
<p>时间复杂度(最差)：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：不稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = SortUtil.array1;</span><br><span class="line">        <span class="comment">//用minIndex作为最小部分的下标</span></span><br><span class="line">        <span class="keyword">int</span> minIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里上限为array.length-1是为了防止j越界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这一步很关键，每次在无序部分进行新一轮循环时都要重新初始化最小下标</span></span><br><span class="line">            <span class="comment">//因为不知道哪个是最小值则用第一个下标做minIndex</span></span><br><span class="line">            minIndex=i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;array.length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//每当遇到比最小下标元素更小的元素时就更新最小下标</span></span><br><span class="line">                <span class="keyword">if</span>(array[j]&lt;array[minIndex])</span><br><span class="line">                    minIndex=j;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">int</span> temp=array[i];</span><br><span class="line">            array[i]=array[minIndex];</span><br><span class="line">            array[minIndex]=temp; </span><br><span class="line">        &#125;</span><br><span class="line">        SortUtil.printArray(array);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h2><p>插入排序的特点是也像选择排序那样分成有序和无序部分，不过它的第二轮循环没有遍历无序部分，而是遍历有序部分与无序部分的第一个元素进行比较，如果满足条件则将这当前元素插入到有序部分中，这里的插入是从后往前插</p>
<p>时间复杂度(平均)：O(n^2)</p>
<p>时间复杂度(最好)：O(n)</p>
<p>时间复杂度(最差)：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = SortUtil.array1;</span><br><span class="line">        <span class="comment">//设置前面有序序列的替换下标、当前值</span></span><br><span class="line">        <span class="keyword">int</span> preIndex,current;</span><br><span class="line">        <span class="comment">//循环要从1开始，因为要预留下标0给preIndex</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            preIndex=i-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//这里要用current记录下标i的值，而不能直接记录下标i，因为后面下标i的元素会被替换掉</span></span><br><span class="line">            current=array[i];</span><br><span class="line">            <span class="comment">//这里判断前面的下标是否大于当前值且在数组元素内，如果大于就让前面元素向后移位空出一格以备当前元素插入</span></span><br><span class="line">            <span class="keyword">while</span>(preIndex&gt;=<span class="number">0</span> &amp;&amp; array[preIndex]&gt;current)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//前面下标后移一格，下标同时向前移动</span></span><br><span class="line">                array[preIndex+<span class="number">1</span>]=array[preIndex];</span><br><span class="line">                preIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环结束则说明当前元素大于前面元素，此时插入空格位(看起来是空格为但实际上是前面的后移元素)</span></span><br><span class="line">            <span class="comment">//并且这里的preIndex+1是因为在前面循环后preIndex会比空格位对应的下标还要小1，因此要+1得到空格位</span></span><br><span class="line">            array[preIndex+<span class="number">1</span>]=current;</span><br><span class="line">        &#125;</span><br><span class="line">        SortUtil.printArray(array);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h2><p>希尔排序是第一个突破O(n^2)复杂度的排序算法。它是插入排序的优化版本，又叫缩小增量排序，插入排序每次比较的间隔都是1，而希尔排序的比较间隔是从大到小，如果后面的元素满足条件则也会从后往前插入</p>
<p>时间复杂度(平均)：O(n^1.3)</p>
<p>时间复杂度(最好)：O(n)</p>
<p>时间复杂度(最差)：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：不稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = SortUtil.array1;</span><br><span class="line">        <span class="comment">//preIndex作为前面元素下标、gap作为比较间隔、current作为当前元素</span></span><br><span class="line">        <span class="keyword">int</span> preIndex,gap,current; </span><br><span class="line">        <span class="comment">//首先外部有个大循环是用gap作条件，不断缩小比较的间隔，如12-&gt;6-&gt;3-&gt;1</span></span><br><span class="line">        <span class="keyword">for</span>(gap=array.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap=gap/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里的核心部分和插入排序非常相似</span></span><br><span class="line">            <span class="comment">//初始条件i=gap和插入排序的i=1类似</span></span><br><span class="line">            <span class="comment">//初始化preIndex=i-gap和插入排序的i=i-1类似</span></span><br><span class="line">            <span class="comment">//到后面的while循环条件和插入排序直接一致，可以说当gap缩小到1时这段代码就等同于插入排序了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=gap;i&lt;array.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                preIndex=i-gap;</span><br><span class="line">                current=array[i];</span><br><span class="line">                <span class="keyword">while</span>(preIndex&gt;=<span class="number">0</span> &amp;&amp; array[preIndex]&gt;current)</span><br><span class="line">                &#123;</span><br><span class="line">                    array[preIndex+gap]=array[preIndex];</span><br><span class="line">                    preIndex-=gap;</span><br><span class="line">                &#125;</span><br><span class="line">                array[preIndex+gap]=current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SortUtil.printArray(array);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h2><p>归并排序的特点是通过分治法，先把无序队列分成子序列，分成子序列的关键在于变换首尾下标，起初是子序列是整个数组的长度然后慢慢递减到只有1个长度，然后使子序列有序，然后再把有序子序列合并起来，最终得到一个完整的有序序列</p>
<p>时间复杂度(平均)：O(nlogn)</p>
<p>时间复杂度(最好)：O(nlogn)</p>
<p>时间复杂度(最差)：O(nlogn)</p>
<p>空间复杂度：O(n)</p>
<p>稳定性：稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = SortUtil.array1;</span><br><span class="line">        <span class="comment">//用一个辅助数组来帮助实现归并</span></span><br><span class="line">        <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="comment">//初始前后下标设置为数组首尾下标</span></span><br><span class="line">        merge(array,result,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        SortUtil.printArray(array);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//递归方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span>[] result,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//当只有子序列只有一个元素时结束递归，子序列长度由start和end决定</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//首先取一半作为子序列</span></span><br><span class="line">        <span class="keyword">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//前半段子序列下标为start1~end1，后半段下标为start2~end2</span></span><br><span class="line">        <span class="keyword">int</span> start1=start,end1=mid;</span><br><span class="line">        <span class="keyword">int</span> start2=mid+<span class="number">1</span>,end2=end;</span><br><span class="line">        <span class="comment">//然后一直递归直到只有1个元素才会继续后面的代码</span></span><br><span class="line">        merge(array,result,start1,end1);</span><br><span class="line">        merge(array,result,start2,end2);</span><br><span class="line">        <span class="comment">//下面是归并部分，用把两个有序队列合并成一个有序队列来看就很容易理解</span></span><br><span class="line">        <span class="keyword">int</span> k=start;</span><br><span class="line">        <span class="comment">//首先两个有序队列都未遍历完，因此比较后小的插入result数组，同时变换下标</span></span><br><span class="line">        <span class="keyword">while</span>(start1&lt;=end1 &amp;&amp; start2&lt;=end2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[start1]&lt;array[start2])</span><br><span class="line">                result[k++]=array[start1++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result[k++]=array[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当一个队列遍历完后另一个队列就可以直接遍历剩余部分插入到result数组中</span></span><br><span class="line">        <span class="keyword">while</span>(start1&lt;=end1)</span><br><span class="line">            result[k++]=array[start1++];</span><br><span class="line">        <span class="keyword">while</span>(start2&lt;=end2)</span><br><span class="line">            result[k++]=array[start2++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后要修改原数组array，因为result只是一个辅助数组</span></span><br><span class="line">        <span class="keyword">for</span> (k=start;k&lt;=end;k++)</span><br><span class="line">            array[k]=result[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h2><p>快速排序的特点在于选择一个队列左侧的一个值作为基准值，然后通过比较基准值把比基准值小(大)的元素移动到队列前端(队列前端的数都比基准值小，后方都比基准值大)，最后再把基准值移动到前端尾部进行下一轮递归。</p>
<p>时间复杂度(平均)：O(nlogn)</p>
<p>时间复杂度(最好)：O(nlogn)</p>
<p>时间复杂度(最差)：O(n^2)</p>
<p>空间复杂度：O(nlogn)</p>
<p>稳定性：不稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = SortUtil.array1;</span><br><span class="line">        quickSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        SortUtil.printArray(array);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过递归实现快速排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当队列只有一个元素时结束递归</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> partition=getPartition(array,left,right);</span><br><span class="line">            <span class="comment">//左边都小于基准值，右边都大于基准值</span></span><br><span class="line">            quickSort(array,left,partition-<span class="number">1</span>);</span><br><span class="line">            quickSort(array,partition+<span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//分区操作，获得最后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot=left;</span><br><span class="line">        <span class="keyword">int</span> index=pivot+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从基准值后一位开始遍历到右边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i&lt;=right;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果当前元素比基准值小，就与初始遍历位交换，然后下标向后移动一位</span></span><br><span class="line">            <span class="keyword">if</span>(array[i]&lt;array[pivot])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(array,i,index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里index-1是因为前最后一次循环后index还会后移一位到比基准值大的地方</span></span><br><span class="line">        <span class="comment">//而基准值最后要交换的应当是比其小的最大数，因此需要index-1</span></span><br><span class="line">        swap(array,pivot,index-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> index-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换两个下标的数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=array[i];</span><br><span class="line">        array[i]=array[j];</span><br><span class="line">        array[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>(未完待续)….</p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
